<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Circuit Builder: LED Challenge</title>
<style>
  :root{
    --bg0:#070A12;
    --bg1:#0B1430;
    --stroke:rgba(255,255,255,.14);
    --text:#EAF0FF;
    --muted:#AAB7E4;
    --good:#34D399;
    --warn:#FBBF24;
    --bad:#FB7185;
    --accent:#60A5FA;
    --accent2:#A78BFA;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--text);
    background:
      radial-gradient(1200px 800px at 18% 12%, rgba(96,165,250,.25), rgba(0,0,0,0) 60%),
      radial-gradient(900px 650px at 80% 20%, rgba(167,139,250,.20), rgba(0,0,0,0) 55%),
      linear-gradient(180deg, var(--bg1), var(--bg0) 70%);
    min-height:100vh;
  }
  .shell{max-width:1240px;margin:0 auto;padding:14px 18px 28px;}

  /* Top instructions bar */
  .topbar{display:flex;gap:14px;align-items:stretch;justify-content:space-between;flex-wrap:wrap;margin-bottom:14px;}
  .brand{
    display:flex;flex-direction:column;gap:6px;
    padding:14px 14px;border-radius:18px;
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
    border:1px solid var(--stroke);
    box-shadow: 0 18px 38px rgba(0,0,0,.35);
    flex: 1 1 520px;min-width: 280px;
  }
  .brand h1{margin:0;font-size:18px;letter-spacing:.2px;display:flex;align-items:center;gap:10px;}
  .badge{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--muted);font-size:12px;font-weight:700;
  }
  .steps{display:grid;grid-template-columns: 1fr 1fr;gap:10px;margin-top:6px;}
  @media (max-width: 760px){ .steps{grid-template-columns:1fr} }
  .step{
    padding:10px 12px;border-radius:16px;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.10);
    color:var(--muted);font-size:13px;line-height:1.35;
  }
  .step b{color:var(--text)}
  .kbd{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    background: rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.14);
    padding:2px 6px;border-radius:8px;color:#dbe5ff;font-size:12px;white-space:nowrap;
  }

  .rightbar{flex: 0 1 430px;min-width: 280px;display:flex;gap:12px;flex-wrap:wrap;}
  .statCard{
    flex: 1 1 200px;padding:12px 12px;border-radius:18px;
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    border:1px solid var(--stroke);
    box-shadow: 0 18px 38px rgba(0,0,0,.35);
  }
  .statGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .metric{
    padding:10px 10px;border-radius:16px;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.10);
    min-height:64px;
  }
  .k{font-size:12px;color:var(--muted);margin-bottom:5px}
  .v{font-size:16px;font-weight:900;font-variant-numeric: tabular-nums}
  .tiny{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px}

  /* Main layout */
  .layout{display:grid;grid-template-columns: 360px 1fr;gap:16px;}
  @media (max-width: 980px){ .layout{grid-template-columns:1fr} }

  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
    border:1px solid var(--stroke);
    border-radius:20px;
    padding:14px;
    box-shadow: 0 18px 38px rgba(0,0,0,.35);
  }
  .card h2{margin:0 0 12px;font-size:12px;text-transform:uppercase;letter-spacing:.34px;color:#d9e2ff;}

  /* Toolbox */
  .toolRow{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px;}
  .tool{
    display:flex;align-items:center;gap:10px;
    padding:10px 12px;border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    cursor:pointer;user-select:none;
    transition: transform .05s ease, border-color .2s ease, background .2s ease;
  }
  .tool:hover{border-color: rgba(255,255,255,.22)}
  .tool:active{transform: translateY(1px)}
  .tool.active{border-color: rgba(96,165,250,.85);background: rgba(96,165,250,.16);}
  .icon{
    width:28px;height:28px;border-radius:12px;
    display:grid;place-items:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
    font-weight:900;
  }
  .tool .name{display:flex;flex-direction:column;gap:2px;font-size:13px;}
  .tool .name span{color:var(--muted);font-size:12px}

  .buttons{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;}
  button{
    flex:1;
    border:1px solid rgba(255,255,255,.12);
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    color:var(--text);
    padding:11px 12px;border-radius:16px;
    cursor:pointer;font-weight:900;font-size:13px;
    transition: transform .05s ease, border-color .2s ease;
  }
  button:hover{border-color: rgba(255,255,255,.22)}
  button:active{transform: translateY(1px)}
  .primary{
    position:relative;overflow:hidden;
    background: linear-gradient(180deg, rgba(96,165,250,.35), rgba(96,165,250,.12));
    border-color: rgba(96,165,250,.45);
    box-shadow: 0 16px 30px rgba(96,165,250,.18);
  }
  .primary::after{
    content:"";
    position:absolute;inset:-2px;
    background: radial-gradient(420px 140px at 20% 20%, rgba(255,255,255,.18), rgba(255,255,255,0) 60%);
    pointer-events:none;
  }

  /* Challenge prompt (make it stand out + at top of toolbox) */
  .challengeBox{
    margin: 0 0 12px;
    padding: 12px 12px;
    border-radius: 18px;
    border: 1px solid rgba(96,165,250,.45);
    background:
      radial-gradient(500px 200px at 15% 20%, rgba(96,165,250,.18), rgba(0,0,0,0) 60%),
      rgba(255,255,255,.04);
    box-shadow: 0 16px 30px rgba(0,0,0,.25);
  }
  .challengeTitle{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    margin-bottom:8px;
  }
  .challengeTitle b{letter-spacing:.2px}
  .chip{
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.05);
    color: var(--muted);
    font-size:12px;font-weight:900;
  }
  .challengeText{color:var(--muted);font-size:13px;line-height:1.35;}
  .challengeText b{color:var(--text)}

  /* Resistor dropdown */
  .pickerLabel{color: var(--muted); font-size:12px; margin: 0 0 6px 2px;}
  .picker{
    width:100%;
    padding:12px 12px;border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    color: var(--text);
    font-weight:900;
    outline:none;
    appearance:none;
  }
  .pickerHint{color:var(--muted); font-size:12px; margin-top:8px; line-height:1.35;}

  /* Status */
  .status{
    margin-top:12px;
    padding:12px 12px;border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    font-size:13px;line-height:1.35;color:var(--muted);
  }
  .status b{color:var(--text)}
  .status.good{border-color: rgba(52,211,153,.45); background: rgba(52,211,153,.10)}
  .status.warn{border-color: rgba(251,191,36,.45); background: rgba(251,191,36,.10)}
  .status.bad{border-color: rgba(251,113,133,.45); background: rgba(251,113,133,.10)}

  /* Canvas */
  .boardWrap{padding:14px;}
  .boardTop{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:10px;}
  .pill{
    display:inline-flex;gap:8px;align-items:center;
    padding:8px 10px;border-radius:999px;
    background: rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    color:var(--muted);font-size:12px;font-weight:800;
  }
  .pill strong{color:var(--text)}
  
  canvas{
    width:100%;height:auto;
    border-radius:20px;
    border:1px solid rgba(255,255,255,.12);
    display:block;
    background:
      radial-gradient(900px 600px at 40% 20%, rgba(96,165,250,.10), rgba(0,0,0,0) 60%),
      linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    box-shadow: 0 18px 38px rgba(0,0,0,.35);
    aspect-ratio: 1 / 1;
    height: auto;
  }

  .footerHint{margin-top:10px;color:var(--muted);font-size:12px;line-height:1.35;}
</style>
</head>
<body>
  <div class="shell">
    <div class="topbar">
      <div class="brand">
        <h1>âš¡ Circuit Builder: LED Challenge <span class="badge">Series loop model</span></h1>
        <div class="steps">
          <div class="step"><b>1)</b> Pick a tool (<span class="kbd">1</span> Wire, <span class="kbd">2</span> Battery, <span class="kbd">3</span> Resistor, <span class="kbd">4</span> LED, <span class="kbd">E</span> Eraser)</div>
          <div class="step"><b>2)</b> Click <b>two adjacent nodes</b> to place a part between them. Make a single closed loop.</div>
          <div class="step"><b>3)</b> Goal: LED turns <b>ON</b> but stays under the max current (no burnout).</div>
          <div class="step"><b>Tip</b>: If LED burns, add more resistance. If it's dim, reduce resistance.</div>
        </div>
      </div>

      <div class="rightbar">
        <div class="statCard">
          <div class="statGrid">
            <div class="metric">
              <div class="k">Battery</div>
              <div class="v" id="mV">â€”</div>
            </div>
            <div class="metric">
              <div class="k">Total R</div>
              <div class="v" id="mR">â€”</div>
            </div>
            <div class="metric">
              <div class="k">Current I</div>
              <div class="v" id="mI">â€”</div>
            </div>
            <div class="metric">
              <div class="k">LED</div>
              <div class="v" id="mLED">â€”</div>
            </div>
          </div>
          <div class="tiny">
            Uses <b>I = (V âˆ’ V<sub>f</sub>)/R</b>. One battery + one LED + â‰¥1 resistor in a single loop.
          </div>
        </div>
      </div>
    </div>

    <div class="layout">
      <section class="card">
        <h2>Toolbox</h2>

        <!-- Challenge prompt at TOP of materials/toolbox -->
        <div class="challengeBox" id="challengeBox">
          <div class="challengeTitle">
            <b>Challenge</b>
            <span class="chip" id="challengeChip">Ready</span>
          </div>
          <div class="challengeText" id="challengeText">
            Click <b>New Challenge</b> to randomize the battery + LED limits, then build a safe loop.
          </div>
        </div>

        <!-- Tools -->
        <div class="toolRow" id="toolRow">
          <div class="tool active" data-tool="wire">
            <div class="icon">ðŸ§µ</div>
            <div class="name">Wire <span>Connect nodes</span></div>
          </div>
          <div class="tool" data-tool="battery">
            <div class="icon" style="background:rgba(251,191,36,.16); border-color:rgba(251,191,36,.30)">ðŸ”‹</div>
            <div class="name">Battery <span>Voltage source</span></div>
          </div>
          <div class="tool" data-tool="resistor">
            <div class="icon" style="background:rgba(96,165,250,.16); border-color:rgba(96,165,250,.30)">ðŸ§±</div>
            <div class="name">Resistor <span>Limits current</span></div>
          </div>
          <div class="tool" data-tool="led">
            <div class="icon" style="background:rgba(52,211,153,.12); border-color:rgba(52,211,153,.28)">ðŸ’¡</div>
            <div class="name">LED <span>Lights up safely</span></div>
          </div>
          <div class="tool" data-tool="eraser">
            <div class="icon" style="background:rgba(251,113,133,.14); border-color:rgba(251,113,133,.28)">ðŸ§½</div>
            <div class="name">Eraser <span>Remove parts</span></div>
          </div>
        </div>

        <!-- Resistor dropdown (shows only when Resistor tool is selected) -->
        <div id="resistorPicker" style="display:none; margin: 6px 0 12px;">
          <div class="pickerLabel">Resistor value</div>
          <select id="resistorValue" class="picker">
            <option value="100">100 Î©</option>
            <option value="220" selected>220 Î©</option>
            <option value="330">330 Î©</option>
            <option value="470">470 Î©</option>
            <option value="1000">1000 Î© (1k)</option>
            <option value="2000">2000 Î© (2k)</option>
            <option value="4700">4700 Î© (4.7k)</option>
          </select>
          <div class="pickerHint">Tip: Higher resistance â†’ lower current (safer). Lower resistance â†’ brighter (risk burnout).</div>
        </div>

        <!-- Status -->
        <div class="status" id="statusBox"></div>

        <!-- Buttons at BOTTOM of materials -->
        <div class="buttons">
          <button id="clearBtn">Clear</button>
          <button class="primary" id="challengeBtn">New Challenge</button>
        </div>

        <div class="footerHint">
          Place parts by clicking a node, then an <b>adjacent</b> node. (Up / down / left / right)
        </div>
      </section>

      <section class="card boardWrap">
        <div class="boardTop">
          <div class="pill">Mode: <strong id="modePill">Place</strong></div>
          <div class="pill">Selected tool: <strong id="toolPill">Wire</strong></div>
        </div>
        <canvas id="board" width="900" height="900"></canvas>
        <div class="footerHint">
          Click one node (it highlights), then click an adjacent node to place the chosen component between them.
        </div>
      </section>
    </div>
  </div>

<script>
/**
 * Circuit Builder: series-loop learning game
 * - Place parts between adjacent nodes
 * - Detect a single closed loop
 * - Require exactly 1 battery + 1 LED + >=1 resistor
 * - Compute I = (V - Vf)/R and show safe / dim / burnout feedback
 */

const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

// Grid
const COLS = 14, ROWS = 8;
const PAD = 30;
const W = canvas.width, H = canvas.height;
const GW = W - PAD*2, GH = H - PAD*2;
const dx = GW/(COLS-1), dy = GH/(ROWS-1);

// UI
const toolRow = document.getElementById("toolRow");
const resistorPicker = document.getElementById("resistorPicker");
const resistorValue = document.getElementById("resistorValue");

const statusBox = document.getElementById("statusBox");
const mV = document.getElementById("mV");
const mR = document.getElementById("mR");
const mI = document.getElementById("mI");
const mLED = document.getElementById("mLED");
const toolPill = document.getElementById("toolPill");
const modePill = document.getElementById("modePill");

const challengeText = document.getElementById("challengeText");
const challengeChip = document.getElementById("challengeChip");

// Game state
let tool = "wire";
let pendingNode = null;
let hoverNode = null;

// Challenge parameters
let targetV = 9;
let ledVf = 2.0;
let ledImin = 0.010; // 10mA
let ledImax = 0.020; // 20mA
let burned = false;

// Resistor selection
let selectedResistorOhms = Number(resistorValue.value);
resistorValue.addEventListener("change", () => {
  selectedResistorOhms = Number(resistorValue.value);
});

// Edge components: key -> component
const edges = new Map();

function edgeKey(a,b){
  const s1 = `${a.r},${a.c}`, s2 = `${b.r},${b.c}`;
  return (s1 < s2) ? `${s1}|${s2}` : `${s2}|${s1}`;
}
function parseKey(key){
  const [p1,p2] = key.split("|");
  const [r1,c1] = p1.split(",").map(Number);
  const [r2,c2] = p2.split(",").map(Number);
  return [{r:r1,c:c1},{r:r2,c:c2}];
}
function nodeToXY(r, c) {
  return { x: c * dx, y: r * dy };
}

function defaultComponent(type){
  if(type==="wire") return { type, label:"" };
  if(type==="battery") return { type, value:targetV, label:`${targetV}V` };
  if(type==="resistor") return { type, value:selectedResistorOhms, label:`${selectedResistorOhms}Î©` };
  if(type==="led") return { type, label:"LED" };
  return { type };
}

/* Tool switching */
toolRow.addEventListener("click", (e) => {
  const t = e.target.closest(".tool");
  if(!t) return;
  setTool(t.dataset.tool);
});

function setTool(t){
  tool = t;
  [...toolRow.querySelectorAll(".tool")].forEach(x => x.classList.toggle("active", x.dataset.tool===tool));
  toolPill.textContent = toolLabel(tool);
  modePill.textContent = (tool==="eraser") ? "Erase" : "Place";
  resistorPicker.style.display = (tool === "resistor") ? "block" : "none";
}

function toolLabel(t){
  return t==="wire" ? "Wire" :
         t==="battery" ? "Battery" :
         t==="resistor" ? "Resistor" :
         t==="led" ? "LED" :
         "Eraser";
}

window.addEventListener("keydown", (e)=>{
  const k = e.key.toLowerCase();
  const map = { "1":"wire", "2":"battery", "3":"resistor", "4":"led", "e":"eraser" };
  if(map[k]) setTool(map[k]);
});

/* Hover highlight (outside click handler!) */
canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);

  hoverNode = nearestNode(x, y);
  canvas.style.cursor = hoverNode ? "pointer" : "default";
  render(evaluateCircuit());
});

/* Click placement */
canvas.addEventListener("click", (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  const n = nearestNode(x,y);
  if(!n) return;

  if(!pendingNode){
    pendingNode = n;
    render(evaluateCircuit());
    return;
  }

  // must be adjacent (Manhattan distance = 1)
  const man = Math.abs(pendingNode.r - n.r) + Math.abs(pendingNode.c - n.c);
  if(man !== 1){
    pendingNode = n; // retarget
    render(evaluateCircuit());
    return;
  }

  const key = edgeKey(pendingNode, n);

  if(tool === "eraser"){
    edges.delete(key);
  } else {
    edges.set(key, defaultComponent(tool));
  }

  pendingNode = null;
  render(evaluateCircuit());
});

function nearestNode(x,y){
  // adjust for the drawBoard() translate(PAD, PAD)
  const lx = x - PAD;
  const ly = y - PAD;

  let best=null, bestD=1e9;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const p = nodeToXY(r,c); // now 0..GW / 0..GH
      const d = Math.hypot(p.x-lx, p.y-ly);
      if(d < bestD){ bestD=d; best={r,c}; }
    }
  }
  return bestD < 55 ? best : null;
}

/* Graph helpers */
function buildAdjacency(){
  const adj = new Map();
  function add(u,v,key,comp){
    const ku = `${u.r},${u.c}`;
    const kv = `${v.r},${v.c}`;
    if(!adj.has(ku)) adj.set(ku, []);
    adj.get(ku).push({ to: kv, key, comp });
  }
  for(const [key, comp] of edges.entries()){
    const [a,b] = parseKey(key);
    add(a,b,key,comp);
    add(b,a,key,comp);
  }
  return adj;
}
function findOneCycle(adj){
  const visited = new Set();
  const parent = new Map();
  let cycle = null;

  function dfs(u, pu){
    visited.add(u);
    for(const e of (adj.get(u)||[])){
      const v = e.to;
      if(v === pu) continue;
      if(!visited.has(v)){
        parent.set(v, { node:u, key:e.key });
        if(dfs(v,u)) return true;
      } else {
        cycle = reconstruct(u, v, e.key);
        return true;
      }
    }
    return false;
  }
  function reconstruct(u, v, closingKey){
    const edgesPath = [];
    let cur = u;
    while(cur !== v){
      const par = parent.get(cur);
      if(!par) break;
      edgesPath.push(par.key);
      cur = par.node;
    }
    edgesPath.push(closingKey);
    return [...new Set(edgesPath)];
  }

  for(const node of adj.keys()){
    if(!visited.has(node)){
      parent.set(node, null);
      if(dfs(node, null)) break;
    }
  }
  return cycle;
}

/* Evaluation */
function evaluateCircuit(){
  const adj = buildAdjacency();
  const cycleEdges = findOneCycle(adj);

  let batteryEdges = [];
  let ledEdges = [];
  let resistors = [];

  for(const [key, comp] of edges.entries()){
    if(comp.type==="battery") batteryEdges.push(key);
    if(comp.type==="led") ledEdges.push(key);
    if(comp.type==="resistor") resistors.push(key);
  }

  // Update the top â€œChallengeâ€ prompt to match current parameters
  challengeChip.textContent = `${targetV}V â€¢ Vfâ‰ˆ${ledVf.toFixed(2)}V`;
  challengeText.innerHTML =
    `Keep current between <b>${(ledImin*1000).toFixed(0)}â€“${(ledImax*1000).toFixed(0)} mA</b>.
     Build one loop with <b>1 battery</b>, <b>1 LED</b>, and <b>â‰¥1 resistor</b>.`;

  if(edges.size === 0){
    return { ok:false, tone:"warn", msg:"Start by placing a <b>Battery</b> and some <b>Wires</b> to form a loop." };
  }
  if(!cycleEdges || cycleEdges.length < 4){
    return { ok:false, tone:"warn", msg:"Make a <b>closed loop</b>. Try drawing a rectangle loop with wires." };
  }

  const cycleSet = new Set(cycleEdges);
  const outOfLoop = [...edges.keys()].filter(k => !cycleSet.has(k));
  if(outOfLoop.length > 0){
    return { ok:false, tone:"warn", msg:"Some parts are not on the main loop. Keep everything in <b>one</b> closed loop." };
  }

  if(batteryEdges.length !== 1){
    return { ok:false, tone:"warn", msg:"Place <b>exactly one</b> battery in the loop." };
  }
  if(ledEdges.length !== 1){
    return { ok:false, tone:"warn", msg:"Place <b>exactly one</b> LED in the loop." };
  }
  if(resistors.length < 1){
    return { ok:false, tone:"warn", msg:"Add at least <b>one resistor</b> in series to protect the LED." };
  }

  let R = 0;
  for(const k of resistors) R += edges.get(k).value;
  const V = edges.get(batteryEdges[0]).value;

  const Vavail = Math.max(0, V - ledVf);
  const I = Vavail / R;

  if(burned){
    return { ok:true, V, R, I, led:"BURNED", tone:"bad",
      msg:"LED is <b>burned out</b>. Click <b>New Challenge</b> or <b>Clear</b> and try again with more resistance." };
  }

  if(I > ledImax){
    burned = true;
    return { ok:true, V, R, I, led:"BURNED", tone:"bad",
      msg:`Overcurrent! <b>${(I*1000).toFixed(1)} mA</b> exceeded the max <b>${(ledImax*1000).toFixed(0)} mA</b>. The LED burned out.` };
  }

  if(I >= ledImin){
    return { ok:true, V, R, I, led:"ON", tone:"good",
      msg:`âœ… Nice! LED is <b>ON</b> at <b>${(I*1000).toFixed(1)} mA</b>. Keep it under <b>${(ledImax*1000).toFixed(0)} mA</b>.` };
  }

  return { ok:true, V, R, I, led:"DIM", tone:"warn",
    msg:`Circuit works, but LED is <b>dim</b> (${(I*1000).toFixed(1)} mA). Try lowering resistance (but stay under ${(ledImax*1000).toFixed(0)} mA).` };
}

/* Rendering */
function render(res){
  if(res.ok && res.V != null){
    mV.textContent = `${res.V.toFixed(1)} V`;
    mR.textContent = `${res.R.toFixed(0)} Î©`;
    mI.textContent = `${(res.I*1000).toFixed(1)} mA`;
    mLED.textContent = res.led;
    mLED.style.color = res.led==="ON" ? "var(--good)" : res.led==="DIM" ? "var(--warn)" : "var(--bad)";
  } else {
    mV.textContent = "â€”";
    mR.textContent = "â€”";
    mI.textContent = "â€”";
    mLED.textContent = "â€”";
    mLED.style.color = "var(--text)";
  }

  statusBox.className = `status ${res.tone || "warn"}`;
  statusBox.innerHTML = res.msg || "Place parts to begin.";

  drawBoard(res);
}

function drawBoard(res){
  ctx.clearRect(0,0,W,H);

  // soft vignette
  const g = ctx.createRadialGradient(W*0.35, H*0.25, 10, W*0.5, H*0.5, Math.max(W,H));
  g.addColorStop(0, "rgba(96,165,250,0.10)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // grid lines + content
  ctx.save();
  ctx.translate(PAD, PAD);
  ctx.strokeStyle = "rgba(255,255,255,.06)";
  ctx.lineWidth = 1;

  for(let r=0;r<ROWS;r++){
    ctx.beginPath();
    ctx.moveTo(0, r*dy);
    ctx.lineTo(GW, r*dy);
    ctx.stroke();
  }
  for(let c=0;c<COLS;c++){
    ctx.beginPath();
    ctx.moveTo(c*dx, 0);
    ctx.lineTo(c*dx, GH);
    ctx.stroke();
  }

  // components
  for(const [key, comp] of edges.entries()){
    const [a,b] = parseKey(key);
    const p1 = nodeToXY(a.r,a.c);
    const p2 = nodeToXY(b.r,b.c);
    drawComponent(p1,p2,comp,res);
  }

  // nodes
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const p = nodeToXY(r,c);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 9, 0, Math.PI*2);
      ctx.fillStyle = "rgba(96,165,250,.10)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x, p.y, 5.2, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.88)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,.25)";
      ctx.stroke();
    }
  }

  // hover highlight
  if(hoverNode){
    const p = nodeToXY(hoverNode.r, hoverNode.c);
    ctx.beginPath();
    ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(96,165,250,.95)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // pending highlight
  if(pendingNode){
    const p = nodeToXY(pendingNode.r, pendingNode.c);
    ctx.beginPath();
    ctx.arc(p.x, p.y, 13, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(167,139,250,.95)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  ctx.restore();
}

function drawComponent(p1,p2,comp,res){
  const isHot = (res && res.ok && (res.led==="ON" || res.led==="DIM"));
  const isBurn = (res && res.ok && res.led==="BURNED");

  let stroke = "rgba(255,255,255,.75)";
  let w = 7;

  if(comp.type==="wire"){ stroke = "rgba(255,255,255,.70)"; w = 6; }
  if(comp.type==="battery"){ stroke = "rgba(251,191,36,.95)"; w = 8; }
  if(comp.type==="resistor"){ stroke = "rgba(96,165,250,.95)"; w = 8; }
  if(comp.type==="led"){ stroke = isBurn ? "rgba(251,113,133,.95)" : "rgba(52,211,153,.92)"; w = 8; }

  ctx.save();
  if(isHot){
    ctx.shadowBlur = 16;
    ctx.shadowColor =
      comp.type==="led"
        ? (res.led==="ON" ? "rgba(52,211,153,.95)" : "rgba(251,191,36,.95)")
        : "rgba(96,165,250,.70)";
  }

  ctx.strokeStyle = stroke;
  ctx.lineWidth = w;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(p1.x,p1.y);
  ctx.lineTo(p2.x,p2.y);
  ctx.stroke();

  const mx = (p1.x+p2.x)/2, my=(p1.y+p2.y)/2;

  if(comp.type==="battery"){
    drawBattery(mx,my,p1,p2);
    labelText(`${comp.value}V`, mx, my-18);
  } else if(comp.type==="resistor"){
    drawResistor(mx,my,p1,p2);
    labelText(`${comp.value}Î©`, mx, my-18);
  } else if(comp.type==="led"){
    drawLED(mx,my,p1,p2,res);
    labelText(isBurn ? "LED âœ–" : (res && res.led==="ON" ? "LED âœ“" : "LED"), mx, my-18);
  }

  ctx.restore();
}

function labelText(t,x,y){
  ctx.save();
  ctx.shadowBlur = 0;
  ctx.font = "800 12px ui-sans-serif, system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const padX = 8;
  const w = ctx.measureText(t).width + padX*2;
  const h = 22;

  roundedRect(x - w/2, y - h/2, w, h, 999);
  ctx.fillStyle = "rgba(0,0,0,.30)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.stroke();

  ctx.fillStyle = "rgba(233,240,255,.92)";
  ctx.fillText(t, x, y+1);
  ctx.restore();
}

function roundedRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawBattery(mx,my,p1,p2){
  const vx = p2.x-p1.x, vy=p2.y-p1.y;
  const len = Math.hypot(vx,vy) || 1;
  const nx = -vy/len, ny = vx/len;

  ctx.save();
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(0,0,0,.35)";
  ctx.lineWidth = 2;

  const plateLong = 12, plateShort = 7, gap=6;
  const ax = mx - (vx/len)*gap, ay = my - (vy/len)*gap;
  const bx = mx + (vx/len)*gap, by = my + (vy/len)*gap;

  ctx.beginPath();
  ctx.moveTo(ax + nx*plateLong, ay + ny*plateLong);
  ctx.lineTo(ax - nx*plateLong, ay - ny*plateLong);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(bx + nx*plateShort, by + ny*plateShort);
  ctx.lineTo(bx - nx*plateShort, by - ny*plateShort);
  ctx.stroke();

  ctx.restore();
}

function drawResistor(mx,my,p1,p2){
  const vx=p2.x-p1.x, vy=p2.y-p1.y;
  const len=Math.hypot(vx,vy)||1;
  const ux=vx/len, uy=vy/len;
  const px=-uy, py=ux;

  ctx.save();
  ctx.shadowBlur = 0;
  ctx.strokeStyle="rgba(0,0,0,.35)";
  ctx.lineWidth=2;

  const seg=10, amp=7;
  const start=-24, end=24;
  ctx.beginPath();
  for(let t=start;t<=end;t+=seg){
    const off = (Math.floor((t-start)/seg)%2===0) ? amp : -amp;
    const x = mx + ux*t + px*off;
    const y = my + uy*t + py*off;
    if(t===start) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLED(mx,my,p1,p2,res){
  const vx=p2.x-p1.x, vy=p2.y-p1.y;
  const len=Math.hypot(vx,vy)||1;
  const ux=vx/len, uy=vy/len;
  const px=-uy, py=ux;

  ctx.save();
  ctx.shadowBlur = 0;

  const size=14;
  const ax = mx - ux*8;
  const ay = my - uy*8;

  ctx.fillStyle="rgba(0,0,0,.35)";
  ctx.beginPath();
  ctx.moveTo(ax - px*size*0.75, ay - py*size*0.75);
  ctx.lineTo(ax + px*size*0.75, ay + py*size*0.75);
  ctx.lineTo(ax + ux*size, ay + uy*size);
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle="rgba(0,0,0,.35)";
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(mx + ux*10 + px*size*0.85, my + uy*10 + py*size*0.85);
  ctx.lineTo(mx + ux*10 - px*size*0.85, my + uy*10 - py*size*0.85);
  ctx.stroke();

  if(res && res.ok && res.led==="ON"){
    ctx.strokeStyle="rgba(52,211,153,.95)";
    ctx.lineWidth=2;
    for(let k=-1;k<=1;k++){
      ctx.beginPath();
      ctx.moveTo(mx + ux*14 + px*(10+k*6), my + uy*14 + py*(10+k*6));
      ctx.lineTo(mx + ux*28 + px*(18+k*6), my + uy*28 + py*(18+k*6));
      ctx.stroke();
    }
  }

  ctx.restore();
}

/* Buttons */
document.getElementById("clearBtn").addEventListener("click", ()=>{
  edges.clear();
  burned = false;
  pendingNode = null;
  render(evaluateCircuit());
});

document.getElementById("challengeBtn").addEventListener("click", newChallenge);

function newChallenge(){
  edges.clear();
  burned = false;
  pendingNode = null;

  const Vs = [5, 9, 12];
  targetV = Vs[Math.floor(Math.random()*Vs.length)];
  ledVf = 1.8 + Math.random()*0.5;        // 1.8..2.3V
  ledImin = 0.008 + Math.random()*0.006;  // 8..14mA
  ledImax = 0.018 + Math.random()*0.007;  // 18..25mA

  statusBox.className = "status warn";
  statusBox.innerHTML =
    `New challenge loaded. Battery <b>${targetV}V</b>, LED <b>Vfâ‰ˆ${ledVf.toFixed(2)}V</b>.
     Turn ON above <b>${(ledImin*1000).toFixed(0)}mA</b>, burns above <b>${(ledImax*1000).toFixed(0)}mA</b>.`;

  render(evaluateCircuit());
}

/* Init */
setTool("wire");
statusBox.innerHTML = "Build a single loop, then tune resistance so the LED turns <b>ON</b> without burning out.";
render(evaluateCircuit());
</script>
</body>
</html>